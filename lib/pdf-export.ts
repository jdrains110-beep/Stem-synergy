import jsPDF from 'jspdf'
import { PDFDocument, PDFPage, rgb } from 'pdf-lib'

export async function generateBlueprintPDF(
  name: string,
  svgData: string,
  metadata: {
    rooms: number
    squareFeet: number
    style: string
    description: string
  }
): Promise<Blob> {
  try {
    // Create PDF document
    const doc = new jsPDF({
      orientation: 'landscape',
      unit: 'mm',
      format: 'a3',
    })

    const pageWidth = doc.internal.pageSize.getWidth()
    const pageHeight = doc.internal.pageSize.getHeight()
    const margin = 15

    // Add header
    doc.setFontSize(24)
    doc.setTextColor(0, 102, 204)
    doc.text(`Blueprint: ${name}`, margin, margin + 10)

    // Add metadata
    doc.setFontSize(10)
    doc.setTextColor(100, 100, 100)
    const metadataY = margin + 25

    doc.text(`Style: ${metadata.style}`, margin, metadataY)
    doc.text(`Rooms: ${metadata.rooms}`, margin + 80, metadataY)
    doc.text(`Square Feet: ${metadata.squareFeet.toLocaleString()}`, margin + 130, metadataY)

    // Add description
    doc.setFontSize(9)
    const descriptionY = metadataY + 8
    const descriptionLines = doc.splitTextToSize(
      `Description: ${metadata.description}`,
      pageWidth - 2 * margin
    )
    doc.text(descriptionLines, margin, descriptionY)

    // Add SVG as image
    const svgImage = await svgToImage(svgData)
    const svgY = descriptionY + descriptionLines.length * 4 + 5
    const svgWidth = pageWidth - 2 * margin
    const svgHeight = pageHeight - svgY - margin - 10

    doc.addImage(svgImage, 'PNG', margin, svgY, svgWidth, svgHeight)

    // Add footer
    const footerY = pageHeight - margin
    doc.setFontSize(8)
    doc.setTextColor(150, 150, 150)
    doc.text(
      `Generated by Stem Synergy | ${new Date().toLocaleDateString()}`,
      margin,
      footerY
    )

    // Convert to blob
    return doc.output('blob')
  } catch (error) {
    console.error('PDF generation error:', error)
    throw error
  }
}

async function svgToImage(svgData: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const svg = new Blob([svgData], { type: 'image/svg+xml' })
    const url = URL.createObjectURL(svg)
    const img = new Image()

    img.onload = () => {
      const canvas = document.createElement('canvas')
      canvas.width = img.width
      canvas.height = img.height
      const ctx = canvas.getContext('2d')

      if (ctx) {
        ctx.fillStyle = 'white'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        ctx.drawImage(img, 0, 0)
        resolve(canvas.toDataURL('image/png'))
      }
      URL.revokeObjectURL(url)
    }

    img.onerror = () => {
      URL.revokeObjectURL(url)
      reject(new Error('Failed to load SVG'))
    }

    img.src = url
  })
}

export async function downloadBlueprint(
  name: string,
  svgData: string,
  metadata: {
    rooms: number
    squareFeet: number
    style: string
    description: string
  },
  format: 'pdf' | 'svg' | 'png' = 'pdf'
): Promise<void> {
  let blob: Blob
  let fileName: string

  const cleanName = name.replace(/\s+/g, '-').toLowerCase()

  switch (format) {
    case 'pdf':
      blob = await generateBlueprintPDF(name, svgData, metadata)
      fileName = `${cleanName}-blueprint.pdf`
      break

    case 'svg':
      blob = new Blob([svgData], { type: 'image/svg+xml' })
      fileName = `${cleanName}-blueprint.svg`
      break

    case 'png': {
      const imageData = await svgToImage(svgData)
      const response = await fetch(imageData)
      blob = await response.blob()
      fileName = `${cleanName}-blueprint.png`
      break
    }

    default:
      throw new Error(`Unsupported format: ${format}`)
  }

  // Create download link
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = fileName
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}
